### 청크

청크(Chunk)는 덩어리라는 뜻으로, 여기서는 ptmalloc이 할당한 메모리 공간을 의미한다. 청크는 데이터와 헤더로 구성된다. 헤더는 청크 관리에 필요한 정보를 담고 있으며, 데이터 영역에는 사용자가 입력한 데이터가 저장된다.

![](https://dreamhack-lecture.s3.amazonaws.com/media/4b0c74248164c0b89c3c47d2beed97fd3b22a268520eb070b8c613e70b0d2fb9.png)
헤더는 청크이 상태를 나타내므로 사용 중인 청크(in-use)의 헤더와 해제된 청크(freed)의 헤더는 구조가 다소 다르다.
사용중인 청크는 fd 와 bk 를 사용하지 않고, 그 영역에 사용자가 입력한 데이터를 저장한다.

![[Chunk.png]]


### bin

bin 은 문자 그대로, 사용이 끝난 청크들이 저장되는 객체이다. 메모리의 낭비를 막고, 해제된 청크를 빠르게 재사용할 수 있게 한다.
ptmalloc 에는 총 128개의  bin이 정의되어 있다. 이 중 62개는 smallbin, 63개는 largebin, 1개는 unsortedbin으로 사용되고, 나머지 2개는 사용되지 않는다.

![](https://dreamhack-lecture.s3.amazonaws.com/media/8fad7686a29fc8373d5a0be0e9ca5b52da8688d3d49503d0b6b5effc5ca2ae3c.png)


### smallbin

smallbin 에는 32바이트 이상 1024바이트 미만의 크기를 갖는 청크들이 보관된다.
하나의 의 smallbin에는 같은 크기의 청크들만 보관되며, idex가 증가하면 저장되는 청크들의 크기는 16바이트씩 커집니다. 즉, samllbin[0] 는 32바이트 크기의 청크를 smallbin[61] 에는 1008 바이트 크기의 청크를 보관한다.

smallbin은 원형 이중 연결 리스트 이며, 먼저 해제된 청크가 먼저 재할당된다. 이 같은 방식을 FIFO(First In First Out)라고 부른다.

이중 연결리스트의 특성상, smallbin에 청크를 추가하거나 꺼낼 때 연결 고리를 끊는 과정이 필요하다. 연결고리에서 열쇠를 빼내려면 고리를 잠시 끊어야 하는 것과 같은 이치이다.
ptmalloc은 이 과정을 unlink 라고 부른다.
또한, smallbin 의 청크들은 ptmalloc의 병합대상이다. 메모리 상에서 인접한 두 청크가 해제되어 있고, 이들이 smallbins에 들어있으면 이 둘은 병합된다. 
ptmalloc은 이 과정을 consolidation 이라고 부른다.


![](https://dreamhack-lecture.s3.amazonaws.com/media/c065e7f4759319dfc276a90fd5366eb6f57a96654e32f71ee8bd0371dd785e82.gif)


### fastbin

일반적으로 크기가 작은 청크들이 큰 청크들보다 빈번하게 할당되고 해제된다. 그래서 작은 청크들의 할당과 해제를 효율적으로 하는 게 전체적인 효율성 측면에서 중요한다. 이런 이유로 ptmalloc 은 어떤 크기를 정해두고, 이보다 작은 청크들은 smallbin이 아니라 fastbin에 저장한다. 그리고 이들을 관리할 때는 메모리 단편화보다 속도를 조금 더 우선순위로 둔다.

fastbin에는 32바이트 이상 176바이트 이하 크기의 청크들이 보관되며, 이에 따라 16바이트 단위로 총 10개의 fastbin이 있다. 리눅스는 이 중에서 작은 크기부터 7개의 fastbin만을 사용한다. 즉, 리눅스에서는 32바이트 이상, 128바이트 이하의 청크들을 fastbin에 저장한다.

fastbin은 단일 연결 리스트이다. 단일 연결리스트이므로 청크를 꺼낼 때 꺼낸 청크의 앞과 뒤를 연결하는 unlink 과정을 수행하지 않아도 된다. 또한 fastbin은 속도는 빠르지만 다른 방법에 비해 파편화가 심한 LIFO의 방법으로 사용된다.
이에 따라 나중에 해제된 청크가 먼저 재할당 된다. 마지막으로 fastbin에 저장되는 청크들은 서로 병합되지 않는다.. 그래서 청크 간 병합에 사용되는 연산도 아낄 수 있다.

![](https://dreamhack-lecture.s3.amazonaws.com/media/d5c3e66cda3b4cf335c5e1dd702d8231e8abb7fc43dd1664e5cb824561507c91.gif)


### largebin

largebin은 1024 바이트 이상의 크기를 갖는 청크들이 보관된다. 총 63개의 largebin이 있는데, smallbin, fastbin과 달리 한 largebin에서 일정 범위 안의 크기를 갖는 청크들을 모두 보관한다.
이 범위는 largebin의 인덱스가 증가하면 로그적으로 증가한다. 예를 들어, largebin[0]는 1024 바이트 이상, 1088 바이트 미만의 청크를 보관하며, largebin[32]는 3072 바이트 이상, 3584 바이트 미만의 청크를 보관한다. 이런 방법을 사용하면 적은 수의 largebin으로 다양한 크기를 갖는 청크들을 관리할 수 있다.

largebin은 범위에 해당하는 모든 청크를 보관하기 때문에, 재할당 요청이 발생했을 때 ptmalloc은 그 안에서 크기가 가장 비슷한 청크(best-fit)를 꺼내 재 할당한다. 이 과정을 빠르게 하려고 ptmalloc은 largebin안의 청크를 크기 내림차순으로 정렬한다. largebin으 ㄴ이중 연결리스트이므로 재할당 과정에서 unlink  도 동반된다. 또한, 연속된 largebin 청크들은 병합의 대상이 된다.


### unsortedbin

unsortedbin은 문자 그대로, 분류되지 않은 청크들을 보관하는 bin이다. unsortedbin은 하나만 존재하며, fastbin에 들어가지 않는 모든 청크들은 해제되었을 때 크기를 구분하지 않고 unsortedbin에 보관된다. unsortedbin은 원형 이중 연결 리스트이며 내부적으로 정렬되지는 않는다.

smallbin 크기에 해당하는 청크를 할당 요청하면,  ptmalloc은 fastbin 또는 smallbin을 탐색한 뒤 unsortedbin을 탐색한다. largebin의 크기에 해당하는 청크는 unsortedbin을 먼저 탐색한다. 
unsortedbin에서 적절한 청크가 발견되면 해당 청크를 꺼내어 사용한다. 이 과정에서 탐색된 청크들은 크기에 따라 적절한 bin으로 분류된다.

ptmalloc은 unsortedbin을 활용하여 불필요한 연산을 줄이고, 성능을 최적화한다. 
연구에 따르면, 어떤 청크를 해제한 다음에 비슷한 크기의 청크를 바로 할당하거나, 또는 한번에 여러 청크들을 연속적으로 해제하는 경우가 빈번하게 발생한다고 한다.

전자의 상황에서 unsortedbin을 사용하면, 청크 분류에 낭비되는 비용을 없앨 수 있다. 또한 청크의 크기가 largebin의 범위에 속하면 청크를 연결할 적절한 위치를 탐색해야 하는데 이 과정도 생략할 수 있다. 
한편, 후자의 상황에서는 연속적으로 청크를 해제하면서 병합하고 재분류하는 과정이 반복적으로 발생한다. unsortedbin을 사용하면 이러한 비용도 줄일 수 있다.


### arena

arena는 fastbin, smallbin, largebin 등의 정보를 모두 담고 있는 객체이다. 멀티 쓰레드 환경에서 ptmalloc은 레이스 컨디션을 막기 위해 areana에 접근할 때 arena에 락을 적용한다. 그런데 이 방식을 사용하면 레이스 컨디션은 막을 수 있지만, 반대로 병목 현상을 일으킬 수 있다.

ptmalloc은 이를 최대한 피하기 위해 최대 64개의 arena를 생성할 수 있게 하고 있다. arena에 락이 걸려서 대기해야하는 경우, 새로운 arena를 생성해서 이를 피할 수 있다. 그런데, 생성할 수 있는 갯수가 64개로 제한되어 있으므로 과도한 멀티 쓰레드 환경에서는 결국 병목현상이 발생한다.
그래서 glibc 2.26에서는 tcache를 추가적으로 도입했다.

레이스 컨디션 이란?
레이스 컨디션은 어떤 공유 자원을 여러 쓰레드나 프로세스에서 접근할 때 발생하는 오동작을 의미한다. 예를 들어, 한 쓰레드가 어떤 사용자의 계정 정보를 참조하고 있는데, 다른 스레드가 그 계정 정보를 삭제하면, 참조하고 있던 쓰레드에서는 삭제된 계정 정보를 참조하게 된다. 이는 경우에 따라 심각한 보안 문제로 이어진다.

이런 문제를 막기 위해 멀티 쓰레딩을 지원하는 프로그래밍 언어들은 락(Lock) 기능을 제공한다. 락은 문자 그대로 자물쇠의 역할을 한다. 한 쓰레드에서 어떤 공유 자원에 락을 걸면, 그 공유 자원을 이용하려는 다른 쓰레드는 락이 해제될 때까지 기다려야 한다. 공유 자원을 사용하는 동안 락을 걸어 놓음으로써 다른 쓰레드에 의한 조작을 차단할 수 있고, 레이스 컨디션을 방지할 수 있다.

그런데, 락은 쓰레드를 무제한으로 대기 시키기 때문에, 구현을 잘못하거나 쓰레드의 수가 과다하게 많아지면 병목 현상을 일으킬 수 있다. 락으로 발생하는 대표적인 문제 중 하나가 데드락(Deadlock) 이다. 여러 쓰레드가 서로 물리고 물려서 어떤 스레드도 락을 해제하지 못하는 상황을 의미한다.


### tcache

tcache는 thread local cache의 약자이다. 이름에서 알 수 있듯, 각 쓰레드에 독립적으로 할당되는 캐시 저장소이다. tcache는 glibc 버전 2.26에서 도입되었으며, 멀티 쓰레드 환경에 더욱 최적화된 메모리 관리 매커니즘을 제공한다.

각 쓰레드는 64개의 tcache를 가지고 있다. tcache는 fastbin과 마찬가지로 LIFO 방식으로 사용되는 단일 쓰레드이며, 하나의 tcache는 같은 크기의 청크들만 보관한다. 리눅스는 각 tcache에 보관할 수 있는 청크의 갯수를 7개로 제한하고 있는데, 이는 쓰레드마다 정의되는 tcache의 특성상, 무제한으로 청크를 연결할 수 있으면 메모리가 낭비될 수 있기 때문이다. tcache에 들어간 청크는 병합되지 않는다.

tcache에는 32바이트 이상, 1040 바이트 이하의 크기를 갖는 청크들이 보관된다. 이 범위에 속하는 청크들은 할당 및 해제될 때 tcache를 가장 먼저 조회한다. 청크가 보관될 tcache가 가득찼을 경우에는 적절한 bin으로 분류된다.

tcache는 각 쓰레드가 고유하게 갖는 캐시이기 때문에 , ptmalloc은 레이스 컨디션을 고려하지 않고 이 캐시에 접근할 수 있다. area의 bin에 접근하기 전에 tcache를 먼저 사용하므로 arena에서 발생할 수 있는 병목현상을 완화하는 효과가 있다.

tcache는 보안 검사가 많이 생략되어 있어서 공격자들에게 힙 익스플로잇의 좋은 도구로 활용되고 있다.

![](https://dreamhack-lecture.s3.amazonaws.com/media/000c9f9e6d566f807d8fe5db396c0516ff236b8e466596c5e35f20aca56622a3.gif)



###  마치며

#### 1. Memory Allocator

프로세스의 요청에 따라 동적으로 메모리를 할당 및 해제해 주는 주체, 또는 관련된 알고리즘들의 집합.
dlmalloc, ptmalloc, jemalloc, tcmalloc 등이 있으며, 리눅스는 그 중에서 ptmalloc2를 사용한다. 구현되는 방식은 다소 차이가 있지만, 핵심 목표는 메모리 단편화의 최소화, 공간 복잡도 및 시간 복잡도의 최적화이다.

#### 2. ptmalloc(pthread memory-allocation)

dlmalloc을 모태로 하는 메모리 할당자. malloc, free, realloc등을 기반으로 사용자의 동적 메모리 요청을 처리함. 사용하는 주요 객체로는 청크, bins, arena, tcache 가 있음.

#### 3. 청크(Chunk)
ptmalloc2가 메모리를 할당하는 단위.

#### 4. bins
해제된 청크들을 보관함. ptmalloc은 bin을 이용하여 청크를 빠르게 재할당하고, 단편화를 최소화함. bins는 fastbin, smallbin, largebin, unsortedbin이 있음.

#### 5. arena
ptmalloc이 관리하는 메모리들의 정보가 담겨 있음. 모든 쓰레드가 공유하는 자원으로, 한 쓰레드가 이를 점유하면 race condition을 막기 위해 lock이 걸림. 병목 현상을 막기 위해서 64개까지 생성 가능하지만, 이를 초과할 정도로 많은 연산이 발생하면 병목 현상이 일어남

#### 6. tcache
쓰레드마다 해제된 청크들을 보관하는 저장소. 멀티 쓰레드 환경에서 arena가 가지고 있는 병목 현상의 문제를 일부 해결해 줄 수 있음. 쓰레드마다 할당되므로 용량을 고려하여 각 tcache당 7개의 청크만 보관할 수 있음.

